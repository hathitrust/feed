package HTFeed::Config;

use warnings;
use strict;
use YAML::AppConfigFork;
use Carp;
use File::Basename;
use File::Spec;
use Cwd qw(realpath);

use base qw(Exporter);
our @EXPORT = qw(get_config);
our @EXPORT_OK = qw(set_config get_tool_version);

use Getopt::Long qw(:config pass_through no_ignore_case no_auto_abbrev);

##################################################
#               HTFeed directories               #
#  This block is generated by make, do not edit  #
#  Override these in etc/feed/config if needed   #
##################################################
my $feed_etc = undef; # FEED_ETC
my $feed_bin = undef; # FEED_BIN
my $feed_var = undef; # FEED_VAR

my ($vstring,$full_version_string,$production_ok) = (undef,undef,undef); # HTFEED_VERSION_STRINGS
############ End HTFeed directories ##############

my $config;

init();

## TODO: make get_config die on failed top level requests

sub init{
    # find lib directory
    my $feed_lib;
    my $feed_lib_parent;
    {
        my $this_module = __PACKAGE__ . '.pm';
        $this_module =~ s/::/\//g;
        my $path_to_this_module = dirname($INC{$this_module});
        $feed_lib = realpath "$path_to_this_module/..";
        $feed_lib_parent = realpath "$path_to_this_module/../..";
    }

    # find bin, etc and var if they aren't predefined
    $feed_etc = "$feed_lib_parent/etc" if not defined $feed_etc or !-d $feed_etc;
    $feed_bin = "$feed_lib_parent/bin" if not defined $feed_bin or !-d $feed_bin;
    $feed_var = "$feed_lib_parent/var" if not defined $feed_var or !-d $feed_var;

    # generate a simple base config
    my $base_config = <<"baseyaml";
---
feed_etc: $feed_etc
feed_lib: $feed_lib
feed_bin: $feed_bin
feed_var: $feed_var
baseyaml
    $config = YAML::AppConfigFork->new(string => $base_config);

    my $config_dir = "$feed_etc/config";

    # load config files
    my $filename;
    eval{
        my @config_files = sort(glob("$config_dir/*.yml"));
        push (@config_files, $ENV{HTFEED_CONFIG}) if(defined $ENV{HTFEED_CONFIG});
        foreach my $config_file (@config_files) {
			$filename = $config_file;
            if($config){
                $config->merge(file => $config_file);
            } else {
                $config = YAML::AppConfigFork->new(file => $config_file);
            }
        }
    };
    if ($@){ die ("loading $filename failed: $@"); }

    my $printenv;
    GetOptions ( "printenv" => \$printenv );
    if ($printenv) {
        print $config->dump();
        exit 0;
    }
 
    ## TODO: check file validity, can't do this until we establish what the file will look like
    ## TODO: test script to dig out all the config vars and check against config file
}

sub get_config{
    # drill down to the leaf
    my $cursor = $config->get(shift @_);
    foreach my $hashlevel (@_) {
        # die if we try to traverse the tree past a leaf
        croak( sprintf("%s is not in the config file", join('=>',@_)) ) if (!ref($cursor));
        $cursor = $cursor->{$hashlevel};
        
        # die if we try to traverse the tree where no path exists
        croak( sprintf("%s is not in the config file", join('=>',@_)) ) if (not defined $cursor);
    }
    return $cursor;
}

# this probably shouldn't be used in production, but will be quite helpful in test scripts
sub set_config{
    my $setting = shift;
    my $leaf = pop;

    if(!@_) {
        $config->set($leaf,$setting);
    } else {
        my $topkey = shift @_;
        my $topval = $config->get($topkey);
        my $cursor = $topval;
        foreach my $hashlevel (@_) {
            $cursor = $cursor->{$hashlevel};
            croak( sprintf("%s is not in the config file", join('=>',@_,$leaf)) ) if (! ref($cursor));
        }
        $cursor->{$leaf} = $setting;
        $config->set($topkey,$topval);
    }

    return 1;
}

sub _dump {
    print $config->dump();
}

sub get_tool_version {

    my $package_id = shift;
    my $to_eval    = get_config( 'premis_tools', $package_id );
    if ( !$to_eval ) {
        croak("Configuration error: $package_id missing from premis_tools");
        return $package_id;
    }

    my $version = eval($to_eval);
    if ( $@ or !$version ) {
        croak("Error getting version for $package_id: $@");
        return $package_id;
    }
    else {
        return $version;
    }
}

sub perl_mod_version {
    my $module  = shift;
    my $mod_req = $module;
    $mod_req =~ s/::/\//g;
    my $toreturn;
    eval { require "$mod_req.pm"; };
    if ($@) {
        croak( "Error loading $module: $@" );
    }
    no strict 'refs';
    my $version = ${"${module}::VERSION"};
    if ( defined $version ) {
        return "$module $version";
    }
    else {
        croak("Can't find ${module}::VERSION" );
    }
}

sub local_directory_version {
    my $package   = shift;
    my $tool_root = get_config("premis_tool_local");
    if ( not -l "$tool_root/$package" ) {
        croak("$tool_root/$package not a symlink" );
    }
    else {
        my $package_target;
        if ( !( $package_target = readlink("$tool_root/$package") ) ) {
            croak("Error in readlink for $tool_root/$package: $!" ) if $!;
            return $package;
        }

        my ($package_version) = ( $package_target =~ /$package-([\w.]+)$/ );
        if ($package_version) {
            return "$package $package_version";
        }
        else {
            croak( "Couldn't extract version from symlink $package_version for $package");
            return $package;
        }

    }
}

sub system_version {
    my $package = shift;
    my $version = `rpm -q $package`;

    if ( $? or $version !~ /^$package[-.\w]+/ ) {
        croak("RPM returned '$version' with status $? for package $package" );
    }
    else {
        chomp $version;
        return $version;
    }
}



1;

__END__

=head1 NAME

HTFeed::Config - Manage HTFeed configuration settings

=head1 SYNOPSIS

Get and Set methods for interaction with config.yml files

=head1 DESCRIPTION

Config.pm provides the mechanism for referencing all configuration values throughout HTFeed.
Helpful methods for getting config values can be found in main class modules such as METS, Volume, and VolumeValidator.

=head2 METHODS

=over 4

=item get_config()

Retrieves a value from a config file

Use get_config to reference a configuration value:

    use HTFeed::Config qw(get_config);
    get_config('staging' => 'ingest');
    get_config('jhove');


=item set_config()

Use set_config to (re)set a config entry after the config file has been loaded.

B<NOTE:> This method should be used for testing purposes only.

    use HTFeed::Config qw(set_config);
    set_config('setting','path'=>'to'=>'my'=>'setting');

=item init()

Loads the appropriate configuration files

=back

=item get_tool_version()

Get the version of a tool defined in the premis_tools section in the configuration file.

$tool_version = get_tool_version($package_identifier);

INSERT_UNIVERSITY_OF_MICHIGAN_COPYRIGHT_INFO_HERE

=cut
